// пример работы с лентой
#define LED_PIN 6       // пин ленты
#define NUMLEDS 64       // кол-во светодиодов

#define ORDER_GRB       // порядок цветов ORDER_GRB / ORDER_RGB / ORDER_BRG

#define COLOR_DEBTH 2   // цветовая глубина: 1, 2, 3 (в байтах)
// на меньшем цветовом разрешении скетч будет занимать в разы меньше места,
// но уменьшится и количество оттенков и уровней яркости!

// ВНИМАНИЕ! define настройки (ORDER_GRB и COLOR_DEBTH) делаются до подключения библиотеки!
#include <microLED.h>

LEDdata leds[NUMLEDS];  // буфер ленты типа LEDdata (размер зависит от COLOR_DEBTH)
microLED strip(leds, NUMLEDS, LED_PIN);  // объект лента

void setup() {
  strip.setBrightness(30);    // яркость (0-255)
  // яркость применяется при выводе .show() !

  strip.clear();   // очищает буфер
  // применяется при выводе .show() !
  
  strip.show(); // выводим изменения на ленту

  // Библиотека поддерживает два варианта работы с лентой:
  // изменение цвета конкретного пикселя при помощи готовой функции
  // или работа с массивом "вручную".
  // Чтобы вывести обновлённый массив на ленту, используется .show()

  // ------------------------------------------
  // методы для заливки конкретного пикселя
  // диод 0, цвет RGB 255 0 0 (красный)
  strip.setRGB(0, 255, 0, 0);

  // диод 1, цвет HSV 30 255 255 (цвет 30, яркость и насыщенность максимум)
  strip.setHSV(1, 30, 255, 255);

  // диод 2, цвет HEX 0x30B210
  strip.setHEX(2, 0x30B210);

  // диод 3, цвет AQUA
  strip.setColor(3, AQUA);

  // диод 4, цвет 1200 (диапазон 0-1530 вдоль радуги)
  strip.colorWheel(4, 1200);

  strip.show(); // выводим изменения на ленту
  delay(2000);

  // цвет любого диода можно получить в виде hex кода и сравнить с другим:
  if (strip.getColorHEX(0) == strip.getColorHEX(1));

  // ------------------------------------------
  // данные функции возвращают конвертированный "цвет", который можно присвоить в массив
  // mRGB(r, g, b);  // RGB 255, 255, 255
  // mWHEEL(color);  // цвета 0-1530
  // mHEX(color);    // HEX цвет
  // mHSV(h, s, v);  // HSV 255, 255, 255
  // mCOLOR(color);  // цвет

  // Например покрасим половину ленты в один, половину в другой
  for (byte i = 0; i < NUMLEDS / 2; i++) {
    leds[i] = mHSV(0, 255, 255);  // красный
  }
  for (byte i = NUMLEDS / 2; i < NUMLEDS; i++) {
    leds[i] = mHSV(80, 255, 255); // примерно зелёный
  }
  strip.show(); // выводим изменения на ленту
  delay(2000);

  // ------------------------------------------
  // Также есть метод setLED, который красит диод цветом
  strip.clear();   // очищает буфер
  
  // диод 0, цвет RGB 255 0 0 (красный)  
  strip.setLED(0, mRGB(255, 0, 0));

  // диод 1, цвет HSV 30 255 255 (цвет 30, яркость и насыщенность максимум)
  strip.setLED(1, mHSV(30, 255, 255));

  // диод 2, цвет HEX 0x30B210
  strip.setLED(2, mHEX(0x30B210));

  // диод 3, цвет AQUA
  strip.setLED(3, mCOLOR(AQUA));

  // диод 4, цвет 1200 (диапазон 0-1530 вдоль радуги)
  strip.setLED(4, mWHEEL(1200));
  
  strip.show(); // выводим изменения на ленту
  delay(2000);
  
  // ------------------------------------------
  // Есть готовая функция для заливки всей ленты цветом - .fill()
  // принимает конвертированный цвет, например от функций выше
  strip.fill(mCOLOR(YELLOW)); // заливаем жёлтым
  strip.show(); // выводим изменения на ленту
  delay(2000);

  // ------------------------------------------
  // Для ускорения ручных заливок можно создать переменную типа LEDdata
  LEDdata value1, value2;
  value1 = mHSV(60, 100, 255);
  value2 = mHSV(190, 255, 190);
  for (byte i = 0; i < NUMLEDS; i++) {
    // заливаем по половине ленты
    if (i < NUMLEDS / 2) leds[i] = value1;
    else leds[i] = value2;
  }
  strip.show(); // выводим изменения на ленту
  delay(2000);
  strip.clear();
}

void loop() {
  // радуга!
  static byte counter = 0;
  for (byte i = 0; i < NUMLEDS; i++) {
    //strip.setHSV(i, counter + i * (255 / NUMLEDS), 255, 255);  // можно так
    leds[i] = mHSV(counter + i * (255 / NUMLEDS), 255, 255); // или в стиле fastLED
  }
  counter += 1;
  strip.show();
  delay(20);
}
